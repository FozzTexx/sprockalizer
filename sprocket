#!/usr/bin/env python3
import argparse
import cv2
import numpy as np
import math

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("file", help="input file")
  parser.add_argument("--frame", type=int, help="frame number to stop at")
  return parser

COLORS = ((0x00,0x00,0x00), (0xaa,0x00,0x00), (0x00,0xaa,0x00), (0xaa,0xaa,0x00),
          (0x00,0x00,0xaa), (0xaa,0x00,0xaa), (0x00,0x55,0xaa), (0xaa,0xaa,0xaa),
          (0x55,0x55,0x55), (0xff,0x55,0x55), (0x55,0xff,0x55), (0xff,0xff,0x55),
          (0x55,0x55,0xff), (0xff,0x55,0xff), (0x55,0xff,0xff), (0xff,0xff,0xff))
CLR_BLACK = COLORS[0]
CLR_BLUE = COLORS[1]
CLR_GREEN = COLORS[2]
CLR_CYAN = COLORS[3]
CLR_RED = COLORS[4]
CLR_MAGENTA = COLORS[5]
CLR_BROWN = COLORS[6]
CLR_LGRAY = COLORS[7]
CLR_GRAY = COLORS[8]
CLR_LBLUE = COLORS[9]
CLR_LGREEN = COLORS[10]
CLR_LCYAN = COLORS[11]
CLR_LRED = COLORS[12]
CLR_LMAGENTA = COLORS[13]
CLR_YELLOW = COLORS[14]
CLR_WHITE = COLORS[15]

# Dimensions in mm
SPROCKET_SUPER8 = (0.914, 1.12)
FRAME_SUPER8 = (5.79, 4.01)
SPROCKET_8MM = ()
FRAME_8MM = (4.5, 3.3)

def line_angle(line):
  return math.atan2(line[0][1] - line[1][1], line[0][0] - line[1][0])

def linify(lines, img):
  vertical = []
  horizontal = []
  thickness = 2
  ANGLE_LIMIT = 10

  if not lines is not None:
    return None, None
  
  for x in range(0, len(lines)):
    for x1,y1,x2,y2 in lines[x]:
      line = ((x1, y1), (x2, y2))
      l =math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
      angle = abs(math.degrees(line_angle(line)))
      if abs(180 - angle) <= ANGLE_LIMIT:
        horizontal.append(line)
      elif abs(90 - angle) <= ANGLE_LIMIT and l > 10:
        vertical.append(line)
  #attrs['vert'] = vertical
  #attrs['horz'] = horizontal

  # Plot vertical lines
  for x in range(0, len(vertical)):
    cv2.line(img, vertical[x][0], vertical[x][1], CLR_LGREEN, thickness)

  # Plot horizontal lines
  for x in range(0, len(horizontal)):
    cv2.line(img, horizontal[x][0], horizontal[x][1], CLR_LRED, thickness)

  return horizontal, vertical

def find_sprocket(size, horizontal, vertical):
  # FIXME - use a percentage
  MARGIN = 20
  RIGHT = 140
  CMAX = 200
  center = size[1] / 2

  spr_top = spr_bot = spr_rgt = None
  
  pts_x = []
  pts_y = []
  for line in vertical:
    if ((line[0][1] > center - CMAX and line[0][1] < center + CMAX) \
        and (line[1][1] > center - CMAX and line[1][1] < center + CMAX)) \
       and line[0][0] < RIGHT and line[1][0] < RIGHT \
       and line[0][0] > 10 and line[1][0] > 10:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    # x_min = np.median(pts_x)
    counts = np.bincount(pts_x)
    x_min = np.argmax(counts)    
    edge = np.where(pts_x < x_min + MARGIN)
    right = int(np.median(np.array(pts_x)[edge]))
    spr_rgt = ((right, 0), (right, size[1] - 1))
    RIGHT = right

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] < center and line[1][1] < center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_max = np.max(pts_y)
    edge = np.where(pts_y > y_max - MARGIN)
    top = int(np.average(np.array(pts_y)[edge]))
    spr_top = ((0, top), (size[0] - 1, top))

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] > center and line[1][1] > center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_min = np.min(pts_y)
    edge = np.where(pts_y < y_min + MARGIN)
    bot = int(np.average(np.array(pts_y)[edge]))
    spr_bot = ((0, bot), (size[0] - 1, bot))

    # bot = np.poly1d(np.polyfit(np.array(pts_x)[edge], np.array(pts_y)[edge], deg=1))
    # bot_l = int(bot(0))
    # bot_r = int(bot(size[0] - 1))
    # spr_bot = ((0, bot_l), (size[0] - 1, bot_r))
    
  return spr_top, spr_bot, spr_rgt

def lines_near(lower, upper, lines, xy):
  pts = []
  if not lines is not None:
    return pts
  for line in lines:
    if line[0][xy] > lower and line[0][xy] < upper \
       and line[1][xy] > lower and line[1][xy] < upper:
      pts.append(line[0])
      pts.append(line[1])
  if not len(pts):
    return pts
  a = np.array(pts)
  return np.array(pts)[:, xy]

def find_frame(size, guess, horizontal, vertical):
  MARGIN = 30

  top = bottom = right = None
  x = guess[1][0]
  r = size[0]
  l = x - MARGIN
  pts_x = lines_near(l, r, vertical, 0)
  if not len(pts_x):
    return None
  right = int(np.median(pts_x))
  y = guess[0][1]
  pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  if not len(pts_y):
    return None
  top = int(np.median(pts_y))
  y = guess[1][1]
  pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  if not len(pts_y):
    return None
  bottom = int(np.median(pts_y))
  return ((guess[0][0], top), (right, bottom))

def main():
  args = build_argparser().parse_args()

  movie = cv2.VideoCapture(args.file)
  cv2.namedWindow("frame", cv2.WINDOW_NORMAL)
  cv2.namedWindow("black", cv2.WINDOW_NORMAL)
  cv2.namedWindow("white", cv2.WINDOW_NORMAL)
  cv2.namedWindow("lines", cv2.WINDOW_NORMAL)

  doStep = True
  singleStep = True
  done = False
  curFrame = 0
  frameSize = None
  fr = None
  if args.frame:
    curFrame = args.frame
    ret = movie.set(cv2.CAP_PROP_POS_FRAMES, curFrame)
  
  while not done:
    if not singleStep or doStep:
      doStep = False
      ret, frame = movie.read()
      if not ret:
        singleStep = True
        doStep = False
      else:
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        center = int(gray.shape[0] / 2)
        gray_f = gray.copy()
        h, w = gray.shape[:2]
        mask = np.zeros((h + 2, w + 2), np.uint8)
        cv2.floodFill(gray_f, mask, (0, center), 255, loDiff=2, upDiff=2);
        mask = mask[1:-1, 1:-1]
        mask *= 255

        # black = np.zeros(shape=gray.shape, dtype=np.uint8)
        # sel = np.where(gray >= 230)
        # black[sel] = gray[sel]
        black_c = cv2.Canny(mask, 50, 100, apertureSize=3)
        kernel = np.ones((2,2), np.uint8) * 255
        black_c = cv2.dilate(black_c, kernel, iterations = 1)

        white = 255 * np.ones(shape=gray.shape, dtype=np.uint8)
        sel = np.where(gray <= 15)
        white[sel] = gray[sel]
        white = 255 - white
        # white = cv2.dilate(white, kernel, iterations = 1)

        # gray_f = white.copy()
        # h, w = gray.shape[:2]
        # mask = np.zeros((h + 2, w + 2), np.uint8)
        # cv2.floodFill(gray_f, mask, (w - 1, center), 255, loDiff=2, upDiff=2);
        # mask = mask[1:-1, 1:-1]
        # mask *= 255
        white_c = cv2.Canny(white, 10, 10, apertureSize=5)
        
        blank = np.zeros(shape=frame.shape, dtype=np.uint8)

        lines1 = cv2.HoughLinesP(black_c, 2, np.pi/180, threshold=10,
                                 minLineLength=5, maxLineGap=5)
        if not lines1 is None:
          for line in lines1:
            line = line[0]
            cv2.line(blank, (line[0], line[1]), (line[2], line[3]), CLR_LBLUE, 3)

        spr_h, spr_v = linify(lines1, blank)

        lines2 = cv2.HoughLinesP(white_c, 2, np.pi/180, threshold=10,
                                 minLineLength=20, maxLineGap=5)
        frm_h, frm_v = linify(lines2, blank)

        newfr = None
        if not spr_h is None and not spr_v is None:
          spr_top, spr_bot, spr_rgt = find_sprocket(frame.shape[1::-1], spr_h, spr_v)
          if not spr_top is None and not spr_bot is None and not spr_rgt is None:
            spr_height = spr_bot[0][1] - spr_top[0][1]
            scale = spr_height / SPROCKET_SUPER8[1]
            center = (spr_bot[0][1] + spr_top[0][1]) / 2
            left = spr_rgt[0][0]
            top = int(center - FRAME_SUPER8[1] * scale / 2)
            right = left + int(FRAME_SUPER8[0] * scale)
            bottom = top + int(FRAME_SUPER8[1] * scale)
            frame_guess = ((left, top), (right, bottom))

            newfr = find_frame(frame.shape[1::-1], frame_guess, frm_h, frm_v)
            if not newfr is None:
              fr = newfr
          else:
            print("NO SPROCKET FOUND")
            singleStep = True

        before = frame
        if not fr is None:
          # cv2.rectangle(frame, fr[0], fr[1], CLR_WHITE, 4)
          if not frameSize is not None:
            frameSize = (fr[1][0] - fr[0][0] - 20, fr[1][1] - fr[0][1] - 20)
          size = frame.shape[1::-1]

          crop = (int(size[0] / 2 - frameSize[0] / 2) + 55,
                  int(size[1] / 2 - frameSize[1] / 2))
          before = frame[crop[1]:crop[1] + frameSize[1], crop[0]:crop[0] + frameSize[0]].copy()
          
          crop = (fr[0][0] + 10, int((fr[0][1] + fr[1][1]) / 2 - frameSize[1] / 2))
          frame = frame[crop[1]:crop[1] + frameSize[1], crop[0]:crop[0] + frameSize[0]]
          # frame = cv2.resize(frame, size)

          if not spr_top is None and not spr_bot is None and not spr_rgt is None:
            cv2.line(blank, spr_top[0], spr_top[1], CLR_YELLOW, 5)
            cv2.line(blank, spr_bot[0], spr_bot[1], CLR_YELLOW, 5)
            cv2.line(mask, spr_rgt[0], spr_rgt[1], CLR_YELLOW, 5)
          cv2.rectangle(mask, crop, (crop[0] + frameSize[0], crop[1] + frameSize[1]),
                        CLR_LBLUE, 4)
          # cv2.rectangle(blank, frame_guess[0], frame_guess[1], CLR_LBLUE, 4)
          
        if not newfr is not None:
          print("NO FRAME FOUND", curFrame)
          singleStep = True
            
        inframe = frame
        label = "%i" % (curFrame)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (0,0,0), 10)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (255,255,255), 7)

        cv2.imshow("frame", inframe)
        cv2.imshow("black", mask)
        cv2.imshow("white", white)
        cv2.imshow("lines", before)

        curFrame += 1
        if args.frame is not None and curFrame == args.frame + 1:
          singleStep = True
          doStep = False
      
    key = cv2.waitKey(1)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
      doStep = True
    elif key == 32:
      singleStep = not singleStep
    elif key == ord('b'):
      singleStep = True
      frame_num = movie.get(cv2.CAP_PROP_POS_FRAMES)
      if frame_num > 1:
        curFrame -= 2
        ret = movie.set(cv2.CAP_PROP_POS_FRAMES, frame_num - 2)
        doStep = True

  cv2.destroyAllWindows()
    
  return

if __name__ == '__main__':
  exit(main() or 0)
