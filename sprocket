#!/usr/bin/env python3
import argparse
import cv2
import numpy as np
from scipy import stats
import math

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("file", help="input file")
  parser.add_argument("--frame", type=int, help="frame number to stop at")
  return parser

COLORS = ((0x00,0x00,0x00), (0xaa,0x00,0x00), (0x00,0xaa,0x00), (0xaa,0xaa,0x00),
          (0x00,0x00,0xaa), (0xaa,0x00,0xaa), (0x00,0x55,0xaa), (0xaa,0xaa,0xaa),
          (0x55,0x55,0x55), (0xff,0x55,0x55), (0x55,0xff,0x55), (0xff,0xff,0x55),
          (0x55,0x55,0xff), (0xff,0x55,0xff), (0x55,0xff,0xff), (0xff,0xff,0xff))
CLR_BLACK = COLORS[0]
CLR_BLUE = COLORS[1]
CLR_GREEN = COLORS[2]
CLR_CYAN = COLORS[3]
CLR_RED = COLORS[4]
CLR_MAGENTA = COLORS[5]
CLR_BROWN = COLORS[6]
CLR_LGRAY = COLORS[7]
CLR_GRAY = COLORS[8]
CLR_LBLUE = COLORS[9]
CLR_LGREEN = COLORS[10]
CLR_LCYAN = COLORS[11]
CLR_LRED = COLORS[12]
CLR_LMAGENTA = COLORS[13]
CLR_YELLOW = COLORS[14]
CLR_WHITE = COLORS[15]

# Dimensions in mm
SPROCKET_SUPER8 = (0.914, 1.09)
FRAME_SUPER8 = (5.77, 4.01)
SPROCKET_8MM = ()
FRAME_8MM = (4.5, 3.3)

def NN(v):
  return not v is None

def line_angle(line):
  return math.atan2(line[0][1] - line[1][1], line[0][0] - line[1][0])

def find_contours(image):
  blank = np.zeros(shape=image.shape, dtype=np.uint8)
  contours, hierarchy = cv2.findContours(image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
  poly = []
  for cnt in contours:
    epsilon = 0.001 * cv2.arcLength(cnt, True)
    approx = cv2.approxPolyDP(cnt, epsilon, True)
    poly.append(approx)
    cv2.drawContours(blank, [approx], -1, 255)
  kernel = np.ones((2,2), np.uint8) * 255
  blank = cv2.dilate(blank, kernel, iterations = 1)
  return blank, np.array(poly)

def draw_lines(img, lines, color, thickness):
  for l in lines:
    cv2.line(img, l[0], l[1], color, thickness)
  return
    
def linify(lines, img, minlen):
  vertical = []
  horizontal = []
  thickness = 2
  ANGLE_LIMIT = 3

  if NN(lines):
    # print("LINIFY", len(lines), lines.shape, lines.ndim)
    if lines.ndim != 3:
      for p in lines:
        h, v = linify(p, img, minlen)
        horizontal.extend(h)
        vertical.extend(v)
    else:
      for x in range(0, len(lines)):
        for le in lines[x]:
          if len(le) == 4:
            x1,y1,x2,y2 = le
          elif len(le) == 2:
            x1,y1 = le
            nx = (x+1) % len(lines)
            x2,y2 = lines[nx][0]
          line = ((x1, y1), (x2, y2))
          l = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
          if l < minlen:
            continue
          angle = abs(math.degrees(line_angle(line)))
          if abs(180 - angle) <= ANGLE_LIMIT:
            horizontal.append(line)
          elif abs(90 - angle) <= ANGLE_LIMIT and l > 10:
            vertical.append(line)

    if NN(img):
      draw_lines(img, vertical, CLR_LGREEN, thickness)
      draw_lines(img, horizontal, CLR_LRED, thickness)

  return horizontal, vertical

def find_sprocket(size, horizontal, vertical):
  MARGIN = int(20 / 1080 * size[0])
  RIGHT = int(140 / 1080 * size[1])
  CMAX = int(200 / 1080 * size[1])
  center = size[1] / 2

  spr_top = spr_bot = spr_rgt = None
  
  pts_x = []
  pts_y = []
  for line in vertical:
    if ((line[0][1] > center - CMAX and line[0][1] < center + CMAX) \
        and (line[1][1] > center - CMAX and line[1][1] < center + CMAX)) \
       and line[0][0] < RIGHT and line[1][0] < RIGHT \
       and line[0][0] > 10 and line[1][0] > 10:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    # x_min = np.median(pts_x)
    counts = np.bincount(pts_x)
    x_min = np.argmax(counts)    
    edge = np.where(pts_x < x_min + MARGIN)
    right = int(np.median(np.array(pts_x)[edge]))
    spr_rgt = ((right, 0), (right, size[1] - 1))
    RIGHT = right

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] < center and line[1][1] < center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_max = np.max(pts_y)
    edge = np.where(pts_y > y_max - MARGIN)
    top = int(np.average(np.array(pts_y)[edge]))
    spr_top = ((0, top), (size[0] - 1, top))

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] > center and line[1][1] > center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_min = np.min(pts_y)
    edge = np.where(pts_y < y_min + MARGIN)
    bot = int(np.average(np.array(pts_y)[edge]))
    spr_bot = ((0, bot), (size[0] - 1, bot))

    # bot = np.poly1d(np.polyfit(np.array(pts_x)[edge], np.array(pts_y)[edge], deg=1))
    # bot_l = int(bot(0))
    # bot_r = int(bot(size[0] - 1))
    # spr_bot = ((0, bot_l), (size[0] - 1, bot_r))
    
  return spr_top, spr_bot, spr_rgt

def longest_near(rc, dist, lines, xy):
  GROUPING = 3
  
  if not NN(lines):
    return None
  # FIXME - group lines into one score
  scores = []
  for line in lines:
    l = math.sqrt((line[0][0] - line[1][0]) ** 2 + (line[0][1] - line[1][1]) ** 2)
    r = (line[0][xy] + line[1][xy]) / 2
    d = abs(rc - r) + 1
    if d > dist:
      continue
    score = l / d
    scores.append([score, r, l, d])
  scores.sort(key=lambda x: x[1])
  scores = np.array(scores)
  #print("SCORES", scores)
  best = None
  idx = 0
  while idx < len(scores):
    score = scores[idx]
    close = scores[np.logical_and(scores[:, 1] >= score[1],
                                  scores[:, 1] <= score[1] + GROUPING)]
    #print("CLOSE", close)
    r = np.average(close[:, 1])
    l = np.sum(close[:, 2])
    d = np.average(close[:, 3])
    s = l / d
    #print("NEAR", rc, dist, s, r, l, d)
    if not NN(best) or s > best[0]:
      best = [s, r, l, d]
    idx += len(close)
  return best

def lines_near(lower, upper, lines, xy):
  pts = []
  if not NN(lines):
    return pts
  for line in lines:
    if line[0][xy] > lower and line[0][xy] < upper \
       and line[1][xy] > lower and line[1][xy] < upper:
      pts.append(line[0])
      pts.append(line[1])
  if not len(pts):
    return pts
  a = np.array(pts)
  return np.array(pts)[:, xy]

def find_frame(frame, guess, previous, horizontal, vertical, spr_found, spr_height, spr_size):
  MARGIN = int(30 / 1080 * frame.shape[0])
  BLACK_LEVEL = 6 * frame.shape[0]

  b_frame = [None, None, None, None, None, None, None, None]
  if NN(guess):
    b_frame[0] = guess[0][0]
  l_frame = b_frame.copy()

  cols = np.sum(frame, axis=0)
  rows = np.sum(frame, axis=1)
  
  x = r = frame.shape[1]
  if NN(guess):
    x = guess[1][0]
  if x > r - MARGIN:
    x = r - MARGIN
  l = x - MARGIN
  re = np.where(cols[l:] < BLACK_LEVEL)
  if len(re[0]):
    b_frame[2] = np.min(re) + l
  else:
    rcols = cols[l:]
    print("RIGHT NOT FOUND", np.min(rcols))

  pts_x = lines_near(l, r, vertical, 0)
  if len(pts_x):
    l_frame[2] = int(np.median(pts_x))
  
  y = MARGIN
  if NN(previous):
    y = previous[0][1]
  elif NN(guess):
    y = guess[0][1]
  if y < MARGIN:
    y = MARGIN
  re = np.where(rows < BLACK_LEVEL)
  re2 = np.where(rows[y - MARGIN:y + MARGIN] < BLACK_LEVEL)
  if (len(re[0]) and np.max(re) < frame.shape[0] / 2) or len(re2[0]):
    if len(re2[0]):
      b_frame[1] = np.max(re2) + y - MARGIN
    else:
      b_frame[1] = np.max(re)
  else:
    trows = rows[:y + MARGIN]
    mrow = np.argmin(trows)
    if NN(previous) and abs(mrow - previous[0][1]) <= 5:
      b_frame[1] = mrow
    else:
      print("TOP NOT FOUND", np.argmin(trows), np.min(trows), y)
      # cv2.line(frame, (0, y + MARGIN), (frame.shape[1] - 1, y + MARGIN), CLR_LGREEN, 3)

  row = longest_near(y, MARGIN, horizontal, 1)
  print("NEAREST-T", row)
  if NN(row):
    l_frame[1] = int(row[1])

  # pts_y2 = pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  # if NN(previous):
  #   pts_y2 = lines_near(previous[0][1] - MARGIN / 2, previous[0][1] + MARGIN / 2,
  #                       horizontal, 1)
  # elif NN(guess):
  #   pts_y2 = lines_near(guess[0][1] - MARGIN, guess[0][1] + MARGIN, horizontal, 1)
  # m1 = stats.mode(pts_y)
  # m2 = stats.mode(pts_y2)
  # percent = (m2.count - m1.count) / m2.count
  # print("PERCENT", percent, len(pts_y2) - len(pts_y), len(pts_y2))
  # if percent > 0.2:
  #   pts_y = pts_y2
  # if len(pts_y):
  #   mode = stats.mode(pts_y)[0][0]
  #   median = int(np.median(pts_y))
  #   print("MODET", mode, median)
  #   l_frame[1] = median
  #   if NN(previous):
  #     print("FARG", previous[0][1])
  #     if abs(mode - previous[0][1]) < abs(median - previous[0][1]):
  #       l_frame[1] = mode
  #   else:
  #     print("NO PREVIOUS")

  right = b_frame[2]
  top = b_frame[1]
  if not right:
    right = l_frame[2]
  if not top:
    top = l_frame[1]
  if not right or not top:
    print("ABORT")
    print(b_frame, "\n", l_frame, "\n", guess, "\n", previous)
    return None
  if NN(previous):
    height = previous[1][1] - previous[0][1]
  elif NN(guess):
    height = guess[1][1] - guess[0][1]
  else:
    height = frame.shape[0] - MARGIN * 2 - top
  y = top + height
  if NN(guess):
    y = guess[1][1]
  if y > top + height:
    y = int(top + height)
  if y >= frame.shape[0]:
    y = frame.shape[0] - MARGIN - 1
  re = np.where(rows[y - MARGIN:] < BLACK_LEVEL)
  if len(re[0]):
    b_frame[3] = np.min(re) + y - MARGIN
  else:
    trows = rows[y - MARGIN:]
    mrow = np.argmin(trows) + y - MARGIN
    print("BOTTOM NOT FOUND", mrow, np.min(trows), y)

  row = longest_near(y, MARGIN, horizontal, 1)
  print("NEAREST-B", y, row)
  if NN(row):
    l_frame[3] = int(row[1])

  # pts_y2 = pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  # if NN(previous):
  #   r1 = previous[1][1] - MARGIN / 2
  #   r2 = previous[1][1] + MARGIN / 2
  #   pts_y2 = lines_near(r1, r2, horizontal, 1)
  #   print("PREVIOUS", r1, r2)
  # elif NN(guess):
  #   pts_y2 = lines_near(guess[1][1] - MARGIN, guess[1][1] + MARGIN, horizontal, 1)
  # m1 = stats.mode(pts_y)
  # m2 = stats.mode(pts_y2)
  # percent = (m2.count - m1.count) / m2.count
  # print("PERCENT", percent, len(pts_y2) - len(pts_y), len(pts_y2))
  # if percent > 0.2 or len(pts_y) == 0:
  #   pts_y = pts_y2
  # print("BOTTOM", len(pts_y), len(pts_y2), y, b_frame[3], height, guess)
  # if len(pts_y):
  #   print("MODEB", stats.mode(pts_y), stats.mode(pts_y2))
  #   l_frame[3] = int(stats.mode(pts_y)[0])

  if NN(b_frame[2]) and NN(b_frame[0]):
    width = b_frame[2] - b_frame[0]
    height = (width / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
    if NN(b_frame[1]):
      b_frame[7] = int(b_frame[1] + height)
    if NN(b_frame[3]):
      b_frame[5] = int(b_frame[3] - height)

  if NN(b_frame[3]) and NN(b_frame[1]):
    height = b_frame[3] - b_frame[1]
    width = (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    if NN(b_frame[0]):
      b_frame[6] = int(b_frame[0] + width)
    if NN(b_frame[2]):
      b_frame[4] = int(b_frame[2] - width)
    
  if NN(l_frame[2]) and NN(l_frame[0]):
    width = l_frame[2] - l_frame[0]
    height = (width / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
    if NN(l_frame[1]):
      l_frame[7] = int(l_frame[1] + height)
    if NN(l_frame[3]):
      l_frame[5] = int(l_frame[3] - height)

  if NN(l_frame[3]) and NN(l_frame[1]):
    height = l_frame[3] - l_frame[1]
    width = (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    if NN(l_frame[0]):
      l_frame[6] = int(l_frame[0] + width)
    if NN(l_frame[2]):
      l_frame[4] = int(l_frame[2] - width)
    
  best = np.array(b_frame)
  missing = np.where(best == None)
  if len(missing[0]):
    best[missing] = np.array(l_frame)[missing]
  if None in best[:4]:
    print("TOO MUCH MISSING")
    print(best, "\n", b_frame, "\n", l_frame, "\n", guess, "\n", previous)
    return None

  if NN(best[1]) and NN(best[2]) \
     and NN(best[3]) and NN(best[7]):
    height = best[3] - best[1]
    w1 = best[2] - (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    height = best[7] - best[1]
    w2 = best[2] - (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    print("WIDTH", w1, w2)
    
  center = 0
  if spr_found and NN(best[1]) and NN(best[3]):
    g_center = (guess[0][1] + guess[1][1]) / 2
    f_center = (best[1] + best[3]) / 2
    center = abs(f_center - g_center)
    print("CENTER", center)
    
  if None not in b_frame[:4] and None not in l_frame[:4] \
     and abs(b_frame[1] - l_frame[1]) < MARGIN / 2 \
     and abs(b_frame[2] - l_frame[2]) < MARGIN / 2 \
     and (abs(b_frame[3] - l_frame[3]) > MARGIN / 2 \
          or abs(best[3] - best[7]) > MARGIN / 2) \
     and (abs(b_frame[7] - l_frame[7]) > 5 or center > MARGIN / 2):
    print("BAD HEIGHT")
    best[3] = best[7]

  altw = alth = prvw = prvh = 0
  if NN(previous):
    prvw = previous[1][0] - previous[0][0]
    prvh = previous[1][1] - previous[0][1]
  curw = best[2] - best[0]
  curh = best[3] - best[1]
  aspw = (curh / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
  asph = (curw / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
  if NN(l_frame[0]) and NN(l_frame[2]):
    altw = l_frame[2] - l_frame[0]
  if NN(l_frame[1]) and NN(l_frame[3]):
    alth = l_frame[3] - l_frame[1]
  if prvw and abs(altw - prvw) < 5:
    best[2] = l_frame[2]
    curw = best[2] - best[0]
    asph = (curw / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
  if prvh and alth and (abs(alth - prvh) < 5 or prvh - curh > MARGIN / 2):
    best[3] = l_frame[3]
    curh = best[3] - best[1]
    aspw = (curh / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
  print("ASPECT", prvw, prvh, curw, curh, aspw, asph, altw, alth)
    
  print("BOUNDS")
  print(best, "\n", b_frame, "\n", l_frame, "\n", guess, "\n", previous)
  print("SPROCKET FIT", spr_found, spr_height, spr_size, abs(spr_height - spr_size))
  if (not spr_found or abs(spr_height - spr_size) > 5) \
     and abs(curw - prvw) > 5 and abs(aspw - prvw) > MARGIN \
     and abs(curw - aspw) > MARGIN:
    print("MOVE LEFT")
    best[0] = int(best[2] - width)
  else:
    if NN(b_frame[2]) and NN(l_frame[2]) \
       and (abs(b_frame[2] - l_frame[2]) <= 5 or abs(curw - prvw) <= 5 \
            or NN((b_frame[1]) and NN(previous) \
                and abs(b_frame[1] - previous[1]) < 5)) \
       and best[1] + asph < frame.shape[0]:
      print("MOVE BOTTOM")
      best[3] = int(best[1] + asph)
    elif abs(asph - curh) < abs(aspw - curw):
      print("MOVE TOP")
      best[1] = int(best[3] - asph)
    else:
      print("MOVE RIGHT", curw, aspw, curh, asph)
      best[2] = int(best[0] + aspw)
  print("FINAL\n", best)
  return (tuple(best[0:2]), tuple(best[2:4]))

def main():
  args = build_argparser().parse_args()

  movie = cv2.VideoCapture(args.file)
  cv2.namedWindow("1", cv2.WINDOW_NORMAL)
  cv2.namedWindow("2", cv2.WINDOW_NORMAL)
  cv2.namedWindow("3", cv2.WINDOW_NORMAL)
  cv2.namedWindow("4", cv2.WINDOW_NORMAL)

  sprockets = []
  spr_size = 0
  doStep = True
  singleStep = True
  done = False
  curFrame = 0
  frameSize = None
  fr = None
  if args.frame:
    curFrame = args.frame
    ret = movie.set(cv2.CAP_PROP_POS_FRAMES, curFrame)
  
  while not done:
    if doStep or not singleStep:
      doStep = False
      ret, frame = movie.read()
      if not ret:
        singleStep = True
        doStep = False
      else:
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        lcheck = np.zeros(shape=frame.shape, dtype=np.uint8)
        
        fr_center = int(gray.shape[0] / 2)
        gate_black = stats.mode(gray[:, -1])[0][0]
        
        gray_f = gray.copy()
        h, w = gray.shape[:2]
        mask = np.zeros((h + 2, w + 2), np.uint8)
        cv2.floodFill(gray_f, mask, (0, fr_center), 255, loDiff=2, upDiff=2);
        sprocket_c = mask[1:-1, 1:-1] * 255

        sprocket_c = cv2.Canny(sprocket_c, 50, 100, apertureSize=3)
        # sprocket_c = find_contours(sprocket_c)

        lines1 = cv2.HoughLinesP(sprocket_c, 2, np.pi/180, threshold=10,
                                 minLineLength=5, maxLineGap=5)
        if NN(lines1):
          for line in lines1:
            line = line[0]
            cv2.line(lcheck, (line[0], line[1]), (line[2], line[3]), CLR_LBLUE, 3)

        spr_h, spr_v = linify(lines1, lcheck, 5)

        newfr = None
        spr_found = False
        if NN(spr_h) and NN(spr_v):
          spr_top, spr_bot, spr_rgt = find_sprocket(frame.shape[1::-1], spr_h, spr_v)
          if NN(spr_top) and NN(spr_bot) and NN(spr_rgt):
            spr_height = spr_bot[0][1] - spr_top[0][1]
            scale = spr_height / SPROCKET_SUPER8[1]
            center = (spr_bot[0][1] + spr_top[0][1]) / 2
            left = spr_rgt[0][0]
            top = int(center - FRAME_SUPER8[1] * scale / 2)
            right = left + int(FRAME_SUPER8[0] * scale)
            bottom = top + int(FRAME_SUPER8[1] * scale)
            if top >= 0 and bottom < gray.shape[0] and right < gray.shape[1]:
              frame_guess = ((left, top), (right, bottom))
              spr_found = True
              sprockets.append([0, spr_top[0][1], spr_rgt[0][0], spr_bot[0][1], spr_height])
              spr_size = stats.mode(np.array(sprockets)[:, 4])[0][0]
              cv2.rectangle(lcheck, frame_guess[0], frame_guess[1], CLR_LBLUE, 3)
          if NN(spr_top):
            cv2.line(lcheck, spr_top[0], spr_top[1], CLR_YELLOW, 5)
          if NN(spr_bot):
            cv2.line(lcheck, spr_bot[0], spr_bot[1], CLR_YELLOW, 5)
          if NN(spr_rgt):
            cv2.line(lcheck, spr_rgt[0], spr_rgt[1], CLR_YELLOW, 5)
 
        if not spr_found:
          print("NO SPROCKET FOUND", curFrame)
          #singleStep = True
          frame_guess = fr
        else:
          print("SPROCKET", spr_top, spr_bot, spr_rgt)

        gate = 255 * np.ones(shape=gray.shape, dtype=np.uint8)
        sel = np.where(gray <= gate_black + 30)
        gate[sel] = gray[sel]
        gate_t = gate.copy()
        gate_t[sel] = 0
                        
        gray_f = gate.copy()
        h, w = gray.shape[:2]
        mask = np.zeros((h + 2, w + 2), np.uint8)
        cv2.floodFill(gray_f, mask, (w - 1, fr_center), 255, loDiff=2, upDiff=2);
        gate = mask[1:-1, 1:-1] * 255

        # gate_c = cv2.Canny(gate, 10, 10, apertureSize=5)

        gate_c, lines2 = find_contours(gate)
        frm_h, frm_v = linify(lines2, None, 20)
        # lines2 = cv2.HoughLinesP(gate_c, 2, np.pi/180, threshold=10,
        #                          minLineLength=40, maxLineGap=5)

        ret, gray_t = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
        gate_t, lines3 = find_contours(gray_t)
        frm2_h, frm2_v = linify(lines3, None, 20)
        # lines3 = cv2.HoughLinesP(gate_t, 2, np.pi/180, threshold=10,
        #                            minLineLength=40, maxLineGap=5)

        if NN(frm_h):
          for line in frm_h:
            cv2.line(gate, (line[0][0], line[0][1]), (line[1][0], line[1][1]), CLR_LRED, 1)

        print("GATE LINES", len(frm_h), len(frm_v), len(frm2_h), len(frm2_v))
        if len(frm2_h) > len(frm_h):
          print("USING GROUP 2")
          gate_c = gate_t
          gate_t = gray_t
        if NN(frm2_h):
          frm_h += frm2_h
        if NN(frm2_v):
          frm_v += frm2_v    

        draw_lines(lcheck, frm_h, CLR_LRED, 2)
        draw_lines(lcheck, frm_v, CLR_LGREEN, 2)
            
        gate_i = 255 - gate
        newfr = find_frame(gate_i, frame_guess, fr, frm_h, frm_v, spr_found,
                           spr_height if spr_found else 0, spr_size)
        # if NN(newfr):
        #   newfr = ((newfr[0][0], int((newfr[0][1] + frame_guess[0][1]) / 2)),
        #            (newfr[1][0], int((newfr[1][1] + frame_guess[1][1]) / 2)))
        if NN(newfr):
          if NN(fr):
            s1 = (newfr[1][0] - newfr[0][0], newfr[1][1] - newfr[0][1])
            s2 = (fr[1][0] - fr[0][0], fr[1][1] - fr[0][1])
            print("SIZE", s1, s2)
          fr = newfr
            
        before = frame
        cropped = None
        if NN(fr):
          if not NN(frameSize) or len(sprockets) < 20:
            frameSize = (fr[1][0] - fr[0][0] - 20, fr[1][1] - fr[0][1] - 20)
          size = frame.shape[1::-1]

          crop = (int(size[0] / 2 - frameSize[0] / 2) + 55,
                  int(size[1] / 2 - frameSize[1] / 2))
          before = frame[crop[1]:crop[1] + frameSize[1], crop[0]:crop[0] + frameSize[0]].copy()
          
          rect = [fr[0][0] + 10, int((fr[0][1] + fr[1][1]) / 2 - frameSize[1] / 2)]
          if rect[0] < 0:
            rect[0] = 0
          if rect[1] < 0:
            rect[1] = 0  
          
          print("CROPPING", rect, fr, frameSize)
          cropped = frame[rect[1]:rect[1] + frameSize[1],
                          rect[0]:rect[0] + frameSize[0]].copy()
          # frame = cv2.resize(frame, size)

          cv2.rectangle(frame, fr[0], fr[1], CLR_WHITE, 4)
          cv2.rectangle(mask, crop, (crop[0] + frameSize[0], crop[1] + frameSize[1]),
                        CLR_LBLUE, 4)
          
        frm_found = True
        if not NN(newfr):
          frm_found = False
          print("NO FRAME FOUND", curFrame, fr, frame_guess)
          #singleStep = True
          if NN(frame_guess):
            if NN(fr):
              center = int((frame_guess[1][1] + frame_guess[0][1]) / 2)
              width = fr[1][0] - fr[0][0]
              height = fr[1][1] - fr[0][1]
              top = int(center - height / 2)
              print("CENTER", center, width, height, top)
              fr = ((frame_guess[0][0], top), (frame_guess[0][0] + width, top + height))
              print("FRAME", fr)
            else:
              fr = frame_guess
            
        if frm_found:
          cv2.rectangle(lcheck, fr[0], fr[1], CLR_WHITE, 4)
          
        inframe = frame
        label = "%i" % (curFrame)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (0,0,0), 10)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (255,255,255), 7)

        cv2.imshow("1", inframe)
        cv2.imshow("2", lcheck)
        cv2.imshow("3", gate_c)
        if NN(cropped):
          cv2.imshow("4", cropped)

        curFrame += 1
        if NN(args.frame) and curFrame == args.frame + 1:
          singleStep = True
          doStep = False
      
    key = cv2.waitKey(1)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
      doStep = True
    elif key == 32:
      singleStep = not singleStep
    elif key == ord('b'):
      singleStep = True
      frame_num = movie.get(cv2.CAP_PROP_POS_FRAMES)
      if frame_num > 1:
        curFrame -= 2
        ret = movie.set(cv2.CAP_PROP_POS_FRAMES, frame_num - 2)
        doStep = True

  cv2.destroyAllWindows()

  if len(sprockets):
    print()
    sprockets = np.array(sprockets)
    size = sprockets[:, 4]
    median = np.median(size)
    mode = stats.mode(size)
    print("SPROCKET SIZE", len(sprockets), median, mode)
    size = sprockets[:, 2]
    median = np.median(size)
    mode = stats.mode(size)
    counts = np.bincount(size)
    print("SPROCKET RIGHT", len(sprockets), median, mode, counts)
    
  return

if __name__ == '__main__':
  exit(main() or 0)
