#!/usr/bin/env python3
import argparse
import cv2
import numpy as np
from scipy import stats
import math

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("file", help="input file")
  parser.add_argument("--frame", type=int, help="frame number to stop at")
  return parser

COLORS = ((0x00,0x00,0x00), (0xaa,0x00,0x00), (0x00,0xaa,0x00), (0xaa,0xaa,0x00),
          (0x00,0x00,0xaa), (0xaa,0x00,0xaa), (0x00,0x55,0xaa), (0xaa,0xaa,0xaa),
          (0x55,0x55,0x55), (0xff,0x55,0x55), (0x55,0xff,0x55), (0xff,0xff,0x55),
          (0x55,0x55,0xff), (0xff,0x55,0xff), (0x55,0xff,0xff), (0xff,0xff,0xff))
CLR_BLACK = COLORS[0]
CLR_BLUE = COLORS[1]
CLR_GREEN = COLORS[2]
CLR_CYAN = COLORS[3]
CLR_RED = COLORS[4]
CLR_MAGENTA = COLORS[5]
CLR_BROWN = COLORS[6]
CLR_LGRAY = COLORS[7]
CLR_GRAY = COLORS[8]
CLR_LBLUE = COLORS[9]
CLR_LGREEN = COLORS[10]
CLR_LCYAN = COLORS[11]
CLR_LRED = COLORS[12]
CLR_LMAGENTA = COLORS[13]
CLR_YELLOW = COLORS[14]
CLR_WHITE = COLORS[15]

# Dimensions in mm
SPROCKET_SUPER8 = (0.914, 1.12)
FRAME_SUPER8 = (5.77, 4.01)
SPROCKET_8MM = ()
FRAME_8MM = (4.5, 3.3)

def line_angle(line):
  return math.atan2(line[0][1] - line[1][1], line[0][0] - line[1][0])

def linify(lines, img):
  vertical = []
  horizontal = []
  thickness = 2
  ANGLE_LIMIT = 10

  if not lines is not None:
    return None, None
  
  for x in range(0, len(lines)):
    for x1,y1,x2,y2 in lines[x]:
      line = ((x1, y1), (x2, y2))
      l =math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
      angle = abs(math.degrees(line_angle(line)))
      if abs(180 - angle) <= ANGLE_LIMIT:
        horizontal.append(line)
      elif abs(90 - angle) <= ANGLE_LIMIT and l > 10:
        vertical.append(line)
  #attrs['vert'] = vertical
  #attrs['horz'] = horizontal

  # Plot vertical lines
  for x in range(0, len(vertical)):
    cv2.line(img, vertical[x][0], vertical[x][1], CLR_LGREEN, thickness)

  # Plot horizontal lines
  for x in range(0, len(horizontal)):
    cv2.line(img, horizontal[x][0], horizontal[x][1], CLR_LRED, thickness)

  return horizontal, vertical

def find_sprocket(size, horizontal, vertical):
  # FIXME - use a percentage
  MARGIN = 20
  RIGHT = 140
  CMAX = 200
  center = size[1] / 2

  spr_top = spr_bot = spr_rgt = None
  
  pts_x = []
  pts_y = []
  for line in vertical:
    if ((line[0][1] > center - CMAX and line[0][1] < center + CMAX) \
        and (line[1][1] > center - CMAX and line[1][1] < center + CMAX)) \
       and line[0][0] < RIGHT and line[1][0] < RIGHT \
       and line[0][0] > 10 and line[1][0] > 10:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    # x_min = np.median(pts_x)
    counts = np.bincount(pts_x)
    x_min = np.argmax(counts)    
    edge = np.where(pts_x < x_min + MARGIN)
    right = int(np.median(np.array(pts_x)[edge]))
    spr_rgt = ((right, 0), (right, size[1] - 1))
    RIGHT = right

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] < center and line[1][1] < center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_max = np.max(pts_y)
    edge = np.where(pts_y > y_max - MARGIN)
    top = int(np.average(np.array(pts_y)[edge]))
    spr_top = ((0, top), (size[0] - 1, top))

  pts_x = []
  pts_y = []
  for line in horizontal:
    if line[0][1] > center and line[1][1] > center \
       and line[0][0] < RIGHT - MARGIN and line[1][0] < RIGHT:
      pts_x.append(line[0][0])
      pts_x.append(line[1][0])
      pts_y.append(line[0][1])
      pts_y.append(line[1][1])
  if len(pts_x):
    y_min = np.min(pts_y)
    edge = np.where(pts_y < y_min + MARGIN)
    bot = int(np.average(np.array(pts_y)[edge]))
    spr_bot = ((0, bot), (size[0] - 1, bot))

    # bot = np.poly1d(np.polyfit(np.array(pts_x)[edge], np.array(pts_y)[edge], deg=1))
    # bot_l = int(bot(0))
    # bot_r = int(bot(size[0] - 1))
    # spr_bot = ((0, bot_l), (size[0] - 1, bot_r))
    
  return spr_top, spr_bot, spr_rgt

def lines_near(lower, upper, lines, xy):
  pts = []
  if not lines is not None:
    return pts
  for line in lines:
    if line[0][xy] > lower and line[0][xy] < upper \
       and line[1][xy] > lower and line[1][xy] < upper:
      pts.append(line[0])
      pts.append(line[1])
  if not len(pts):
    return pts
  a = np.array(pts)
  return np.array(pts)[:, xy]

def find_frame(frame, guess, horizontal, vertical, spr_found):
  MARGIN = 30
  BLACK_LEVEL = 5.7 * frame.shape[0]

  b_frame = [None, None, None, None, None, None, None, None]
  if not guess is None:
    b_frame[0] = guess[0][0]
  l_frame = b_frame.copy()

  cols = np.sum(frame, axis=0)
  rows = np.sum(frame, axis=1)
  
  x = r = frame.shape[1]
  if not guess is None:
    x = guess[1][0]
  if x > r - MARGIN:
    x = r - MARGIN
  l = x - MARGIN
  re = np.where(cols[l:] < BLACK_LEVEL)
  if len(re[0]):
    b_frame[2] = np.min(re) + l
  else:
    rcols = cols[l:]
    print("RIGHT NOT FOUND", np.min(rcols))

  pts_x = lines_near(l, r, vertical, 0)
  if len(pts_x):
    l_frame[2] = int(np.median(pts_x))
  
  y = MARGIN
  if not guess is None:
    y = guess[0][1]
  if y < MARGIN:
    y = MARGIN
  re = np.where(rows[:y + MARGIN] < BLACK_LEVEL)
  if len(re[0]):
    b_frame[1] = np.max(re)
  else:
    trows = rows[:y + MARGIN]
    print("TOP NOT FOUND", np.min(trows))
    # cv2.line(frame, (0, y + MARGIN), (frame.shape[1] - 1, y + MARGIN), CLR_LGREEN, 3)

  pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  if len(pts_y):
    l_frame[1] = int(np.median(pts_y))

  right = b_frame[2]
  top = b_frame[1]
  if not right:
    right = l_frame[2]
  if not top:
    top = l_frame[1]
  if not right or not top:
    print("ABORT", b_frame, l_frame, guess)
    return None
  if not guess is None:
    width = right - guess[0][0]
    height = (width / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
  else:
    height = frame.shape[0] - MARGIN * 2 - top
  y = top + height
  if not guess is None:
    y = guess[1][1]
  if y > top + height:
    y = int(top + height)
  if y >= frame.shape[0]:
    y = frame.shape[0] - MARGIN - 1
  re = np.where(rows[y - MARGIN:] < BLACK_LEVEL)
  if len(re[0]):
    b_frame[3] = np.min(re) + y - MARGIN
  else:
    trows = rows[y - MARGIN:]
    print("BOTTOM NOT FOUND", np.min(trows), guess)

  pts_y = lines_near(y - MARGIN, y + MARGIN, horizontal, 1)
  pts_y2 = lines_near(guess[1][1] - MARGIN, guess[1][1] + MARGIN, horizontal, 1)
  if len(pts_y2) > len(pts_y) + 5:
    pts_y = pts_y2
  print("BOTTOM", len(pts_y), len(pts_y2), y, b_frame[3], height, guess)
  if len(pts_y):
    l_frame[3] = int(np.median(pts_y))

  if b_frame[2] is not None and b_frame[0] is not None:
    width = b_frame[2] - b_frame[0]
    height = (width / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
    if b_frame[1] is not None:
      b_frame[7] = int(b_frame[1] + height)
    if b_frame[3] is not None:
      b_frame[5] = int(b_frame[3] - height)

  if b_frame[3] is not None and b_frame[1] is not None:
    height = b_frame[3] - b_frame[1]
    width = (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    if b_frame[0] is not None:
      b_frame[6] = int(b_frame[0] + width)
    if b_frame[2] is not None:
      b_frame[4] = int(b_frame[2] - width)
    
  if l_frame[2] is not None and l_frame[0] is not None:
    width = l_frame[2] - l_frame[0]
    height = (width / FRAME_SUPER8[0]) * FRAME_SUPER8[1]
    if l_frame[1] is not None:
      l_frame[7] = int(l_frame[1] + height)
    if l_frame[3] is not None:
      l_frame[5] = int(l_frame[3] - height)

  if l_frame[3] is not None and l_frame[1] is not None:
    height = l_frame[3] - l_frame[1]
    width = (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    if l_frame[0] is not None:
      l_frame[6] = int(l_frame[0] + width)
    if l_frame[2] is not None:
      l_frame[4] = int(l_frame[2] - width)
    
  best = np.array(b_frame)
  missing = np.where(best == None)
  if len(missing[0]):
    best[missing] = np.array(l_frame)[missing]

  if best[1] is not None and best[2] is not None \
     and best[3] is not None and best[7] is not None:
    height = best[3] - best[1]
    w1 = best[2] - (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    height = best[7] - best[1]
    w2 = best[2] - (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
    print("WIDTH", w1, w2)
    
  center = 0
  if spr_found and best[1] is not None and best[3] is not None:
    g_center = (guess[0][1] + guess[1][1]) / 2
    f_center = (best[1] + best[3]) / 2
    center = abs(f_center - g_center)
    print("CENTER", center)
    
  if None not in b_frame[:4] and None not in l_frame[:4] \
     and abs(b_frame[1] - l_frame[1]) < MARGIN / 2 \
     and abs(b_frame[2] - l_frame[2]) < MARGIN / 2 \
     and (abs(b_frame[3] - l_frame[3]) > MARGIN / 2 \
          or abs(best[3] - best[7]) > MARGIN / 2) \
     and (abs(b_frame[7] - l_frame[7]) > 5 or center > MARGIN / 2):
    print("BAD HEIGHT")
    best[3] = best[7]

  print("BOUNDS", best, b_frame, l_frame, guess)
  if None in best[:4]:
    return None
  height = best[3] - best[1]
  width = (height / FRAME_SUPER8[1]) * FRAME_SUPER8[0]
  if best[2] - width > MARGIN:
    best[0] = int(best[2] - width)
  else:
    best[2] = int(best[0] + width)
  return (tuple(best[0:2]), tuple(best[2:4]))

def main():
  args = build_argparser().parse_args()

  movie = cv2.VideoCapture(args.file)
  cv2.namedWindow("frame", cv2.WINDOW_NORMAL)
  cv2.namedWindow("black", cv2.WINDOW_NORMAL)
  cv2.namedWindow("white", cv2.WINDOW_NORMAL)
  cv2.namedWindow("lines", cv2.WINDOW_NORMAL)

  doStep = True
  singleStep = True
  done = False
  curFrame = 0
  frameSize = None
  fr = None
  if args.frame:
    curFrame = args.frame
    ret = movie.set(cv2.CAP_PROP_POS_FRAMES, curFrame)
  
  while not done:
    if not singleStep or doStep:
      doStep = False
      ret, frame = movie.read()
      if not ret:
        singleStep = True
        doStep = False
      else:
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        center = int(gray.shape[0] / 2)
        gray_f = gray.copy()
        h, w = gray.shape[:2]
        mask = np.zeros((h + 2, w + 2), np.uint8)
        cv2.floodFill(gray_f, mask, (0, center), 255, loDiff=2, upDiff=2);
        mask = mask[1:-1, 1:-1]
        mask *= 255

        # black = np.zeros(shape=gray.shape, dtype=np.uint8)
        # sel = np.where(gray >= 230)
        # black[sel] = gray[sel]
        black_c = cv2.Canny(mask, 50, 100, apertureSize=3)
        kernel = np.ones((2,2), np.uint8) * 255
        black_c = cv2.dilate(black_c, kernel, iterations = 1)

        white = 255 * np.ones(shape=gray.shape, dtype=np.uint8)
        black_level = stats.mode(gray[:, -1])
        sel = np.where(gray <= black_level[0] + 10)
        white[sel] = 0
        # white = cv2.dilate(white, kernel, iterations = 1)

        # gray_f = white.copy()
        # h, w = gray.shape[:2]
        # mask = np.zeros((h + 2, w + 2), np.uint8)
        # cv2.floodFill(gray_f, mask, (w - 1, center), 255, loDiff=2, upDiff=2);
        # mask = mask[1:-1, 1:-1]
        # mask *= 255
        white_c = cv2.Canny(white, 10, 10, apertureSize=5)
        
        blank = np.zeros(shape=frame.shape, dtype=np.uint8)

        lines1 = cv2.HoughLinesP(black_c, 2, np.pi/180, threshold=10,
                                 minLineLength=5, maxLineGap=5)
        if not lines1 is None:
          for line in lines1:
            line = line[0]
            cv2.line(blank, (line[0], line[1]), (line[2], line[3]), CLR_LBLUE, 3)

        spr_h, spr_v = linify(lines1, blank)

        lines2 = cv2.HoughLinesP(white_c, 2, np.pi/180, threshold=10,
                                 minLineLength=20, maxLineGap=5)
        frm_h, frm_v = linify(lines2, blank)

        newfr = None
        spr_found = False
        if not spr_h is None and not spr_v is None:
          spr_top, spr_bot, spr_rgt = find_sprocket(frame.shape[1::-1], spr_h, spr_v)
          if not spr_top is None and not spr_bot is None and not spr_rgt is None:
            spr_height = spr_bot[0][1] - spr_top[0][1]
            scale = spr_height / SPROCKET_SUPER8[1]
            center = (spr_bot[0][1] + spr_top[0][1]) / 2
            left = spr_rgt[0][0]
            top = int(center - FRAME_SUPER8[1] * scale / 2)
            right = left + int(FRAME_SUPER8[0] * scale)
            bottom = top + int(FRAME_SUPER8[1] * scale)
            if top >= 0 and bottom < gray.shape[0] and right < gray.shape[1]:
              frame_guess = ((left, top), (right, bottom))
              spr_found = True

        if not spr_found:
          print("NO SPROCKET FOUND", curFrame)
          #singleStep = True
          frame_guess = fr

        newfr = find_frame(white, frame_guess, frm_h, frm_v, spr_found)
        if not newfr is None:
          if not fr is None:
            s1 = (newfr[1][0] - newfr[0][0], newfr[1][1] - newfr[0][1])
            s2 = (fr[1][0] - fr[0][0], fr[1][1] - fr[0][1])
            print("SIZE", s1, s2)
          fr = newfr
            
        before = frame
        cropped = None
        if not fr is None:
          if not frameSize is not None:
            frameSize = (fr[1][0] - fr[0][0] - 20, fr[1][1] - fr[0][1] - 20)
          size = frame.shape[1::-1]

          crop = (int(size[0] / 2 - frameSize[0] / 2) + 55,
                  int(size[1] / 2 - frameSize[1] / 2))
          before = frame[crop[1]:crop[1] + frameSize[1], crop[0]:crop[0] + frameSize[0]].copy()
          
          rect = (fr[0][0] + 10, int((fr[0][1] + fr[1][1]) / 2 - frameSize[1] / 2))
          cropped = frame[rect[1]:rect[1] + frameSize[1],
                          rect[0]:rect[0] + frameSize[0]].copy()
          # frame = cv2.resize(frame, size)

          cv2.rectangle(frame, fr[0], fr[1], CLR_WHITE, 4)
          
          if not spr_top is None and not spr_bot is None and not spr_rgt is None:
            cv2.line(blank, spr_top[0], spr_top[1], CLR_YELLOW, 5)
            cv2.line(blank, spr_bot[0], spr_bot[1], CLR_YELLOW, 5)
            cv2.line(blank, spr_rgt[0], spr_rgt[1], CLR_YELLOW, 5)
          cv2.rectangle(mask, crop, (crop[0] + frameSize[0], crop[1] + frameSize[1]),
                        CLR_LBLUE, 4)
          # cv2.rectangle(blank, frame_guess[0], frame_guess[1], CLR_LBLUE, 4)
          
        if not newfr is not None:
          print("NO FRAME FOUND", curFrame, fr, frame_guess)
          #singleStep = True
          if not frame_guess is None:
            if not fr is not None:
              fr = frame_guess
            else:
              center = int((frame_guess[1][1] + frame_guess[0][1]) / 2)
              width = fr[1][0] - fr[0][0]
              height = fr[1][1] - fr[0][1]
              top = int(center - height / 2)
              print("CENTER", center, width, height, top)
              fr = ((frame_guess[0][0], top), (frame_guess[0][0] + width, top + height))
              print("FRAME", fr)
            
        inframe = frame
        label = "%i" % (curFrame)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (0,0,0), 10)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (255,255,255), 7)

        cv2.imshow("frame", inframe)
        cv2.imshow("black", blank)
        cv2.imshow("white", white)
        if not cropped is None:
          cv2.imshow("lines", cropped)

        curFrame += 1
        if args.frame is not None and curFrame == args.frame + 1:
          singleStep = True
          doStep = False
      
    key = cv2.waitKey(1)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
      doStep = True
    elif key == 32:
      singleStep = not singleStep
    elif key == ord('b'):
      singleStep = True
      frame_num = movie.get(cv2.CAP_PROP_POS_FRAMES)
      if frame_num > 1:
        curFrame -= 2
        ret = movie.set(cv2.CAP_PROP_POS_FRAMES, frame_num - 2)
        doStep = True

  cv2.destroyAllWindows()
    
  return

if __name__ == '__main__':
  exit(main() or 0)
