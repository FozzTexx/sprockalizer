#!/usr/bin/env python3
#
# I am the gate finder, are you the sprocket master?

import argparse
import cv2
from sprocket import Sprocket, FRAME_SUPER8, SPROCKET_SUPER8
from line import NN, Bounds
from gate import Gate
import numpy as np
from scipy import stats
import os
from scipy.signal import find_peaks

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("file", help="input file")
  parser.add_argument("stats", nargs="?", help="stats file to read")
  parser.add_argument("--start", default=0, type=int, help="frame number to start at")
  parser.add_argument("--end", default=-1, type=int, help="frame number to stop at")
  return parser

COLORS = ((0x00,0x00,0x00), (0xaa,0x00,0x00), (0x00,0xaa,0x00), (0xaa,0xaa,0x00),
          (0x00,0x00,0xaa), (0xaa,0x00,0xaa), (0x00,0x55,0xaa), (0xaa,0xaa,0xaa),
          (0x55,0x55,0x55), (0xff,0x55,0x55), (0x55,0xff,0x55), (0xff,0xff,0x55),
          (0x55,0x55,0xff), (0xff,0x55,0xff), (0x55,0xff,0xff), (0xff,0xff,0xff))
CLR_BLACK = COLORS[0]
CLR_BLUE = COLORS[1]
CLR_GREEN = COLORS[2]
CLR_CYAN = COLORS[3]
CLR_RED = COLORS[4]
CLR_MAGENTA = COLORS[5]
CLR_BROWN = COLORS[6]
CLR_LGRAY = COLORS[7]
CLR_GRAY = COLORS[8]
CLR_LBLUE = COLORS[9]
CLR_LGREEN = COLORS[10]
CLR_LCYAN = COLORS[11]
CLR_LRED = COLORS[12]
CLR_LMAGENTA = COLORS[13]
CLR_YELLOW = COLORS[14]
CLR_WHITE = COLORS[15]

# FIXME - Make bounds/rect class, sprocket class, filmgate class

def draw_lines(img, lines, color, thickness):
  for l in lines:
    cv2.line(img, l[0], l[1], color, thickness)
  return

def get_mode(arr, col):
  if col is not None:
    a = arr[:, col]
  else:
    a = arr
  a = a[a[:] != None]
  if len(a) == 0:
    return None
  return stats.mode(a)[0][0]

def best_diff(arr, col1, col2):
  offset = arr[:, [col1, col2]]
  ow = np.where(offset == None)
  offset[ow] = np.nan
  offset = np.array(offset, dtype=float)
  offset = offset[~np.isnan(offset).any(1)]
  offset = np.subtract(offset[:, 0], offset[:, 1])
  return stats.mode(offset)[0][0]

def pass1(movie, start, end):
  gate_stats = []
  spr_size = 0
  doStep = singleStep = True
  frameSize = None
  gate = None
  curFrame = start
  done = False

  cv2.namedWindow("1", cv2.WINDOW_NORMAL)
  cv2.namedWindow("2", cv2.WINDOW_NORMAL)
  cv2.namedWindow("3", cv2.WINDOW_NORMAL)
  
  while not done:
    if doStep or not singleStep:
      doStep = False
      ret, frame = movie.read()
      if not ret or curFrame == end:
        if not singleStep:
          done = True
        else:
          singleStep = True
          doStep = False
      else:
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (5, 5), 0)

        lcheck = np.zeros(shape=frame.shape, dtype=np.uint8)

        sprocket = Sprocket(gray)
        gate = Gate(sprocket, gray, gate, spr_size)
        
        fr_center = int(gray.shape[0] / 2)
        gate_black = stats.mode(gray[:, -1])[0][0]

        if sprocket.found:
          cv2.rectangle(lcheck, *sprocket.bounds.cv, CLR_LBLUE, 3)
        if sprocket.top:
          cv2.line(lcheck, (0, sprocket.top), (frame.shape[1], sprocket.top), CLR_YELLOW, 5)
        if sprocket.bottom:
          cv2.line(lcheck, (0, sprocket.bottom), (frame.shape[1], sprocket.bottom),
                   CLR_YELLOW, 5)
        if sprocket.right:
          cv2.line(lcheck, (sprocket.right, 0), (sprocket.right, frame.shape[0]),
                   CLR_YELLOW, 5)
 
        if not sprocket.found:
          print("NO SPROCKET FOUND", curFrame)
          #singleStep = True

        c_stats = [curFrame] + sprocket.stats + gate.stats
        if len(gate_stats) + start > curFrame:
          gate_stats[curFrame - start] = c_stats
        else:
          gate_stats.append(c_stats)
        if len(gate_stats) > 1:
          ng = np.array(gate_stats)[:, 4]
          spr_size = stats.mode(ng[ng[:] != None])[0][0]

        before = frame
        cropped = None
        if gate.found:
          if not NN(frameSize) or len(gate_stats) < 20:
            frameSize = (gate.bounds.width - 20, gate.bounds.height - 20)
          size = frame.shape[1::-1]

          crop = (int(size[0] / 2 - frameSize[0] / 2) + 55,
                  int(size[1] / 2 - frameSize[1] / 2))
          before = frame[crop[1]:crop[1] + frameSize[1], crop[0]:crop[0] + frameSize[0]].copy()
          
          prev_bounds = gate.bounds
        else:
          print("NO FRAME FOUND")

        if NN(gate.bounds):
          rect = [gate.bounds.x1 + 10,
                  int((gate.bounds.y1 + gate.bounds.y2) / 2 - frameSize[1] / 2)]
          if rect[0] < 0:
            rect[0] = 0
          if rect[1] < 0:
            rect[1] = 0  

          print("CROPPING", rect, gate.bounds, frameSize)
          cropped = frame[rect[1]:rect[1] + frameSize[1],
                          rect[0]:rect[0] + frameSize[0]].copy()
          cv2.rectangle(frame, *gate.bounds.cv, CLR_WHITE, 4)
          cv2.rectangle(lcheck, *gate.bounds.cv, CLR_WHITE, 4)
          
        inframe = frame
        label = "%i" % (curFrame)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (0,0,0), 10)
        cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 5, (255,255,255), 7)

        cv2.imshow("1", inframe)
        cv2.imshow("2", lcheck)
        if NN(cropped):
          cv2.imshow("3", cropped)

        curFrame += 1
      
    key = cv2.waitKey(1)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
      doStep = True
    elif key == 32:
      singleStep = not singleStep
    elif key == ord('b'):
      singleStep = True
      frame_num = movie.get(cv2.CAP_PROP_POS_FRAMES)
      if frame_num > 1:
        curFrame -= 2
        ret = movie.set(cv2.CAP_PROP_POS_FRAMES, frame_num - 2)
        doStep = True

  cv2.destroyAllWindows()
  gate_stats = np.array(gate_stats)
  return gate_stats

GS_FRAME = 0
GS_SPRTOP = 1
GS_SPRRGT = 2
GS_SPRBOT = 3
GS_SPRHGT = 4
GS_GATELEF = 5
GS_GATETOP = 6
GS_GATERGT = 7
GS_GATEBOT = 8

def pass2(movie, gate_stats, start, end, path):
  crops = []
  
  print()
  sprocket_height = get_mode(gate_stats, GS_SPRHGT)
  print("SPROCKET HEIGHT", sprocket_height)
  sprocket_right = get_mode(gate_stats, GS_SPRRGT)
  print("SPROCKET RIGHT", sprocket_right)
  gate_offset = int(best_diff(gate_stats, GS_SPRTOP, GS_GATETOP))
  print("FRAME OFFSET", gate_offset)
  gate_width = int(best_diff(gate_stats, GS_GATERGT, GS_GATELEF))
  gate_height = int(best_diff(gate_stats, GS_GATEBOT, GS_GATETOP))
  print("FRAME SIZE", gate_width, 'x', gate_height)
  ideal_width = (FRAME_SUPER8[0] / SPROCKET_SUPER8[1]) * sprocket_height
  ideal_height = (FRAME_SUPER8[1] / SPROCKET_SUPER8[1]) * sprocket_height
  print("IDEAL SIZE", ideal_width, 'x', ideal_height)

  cv2.namedWindow("1", cv2.WINDOW_NORMAL)
  cv2.namedWindow("2", cv2.WINDOW_NORMAL)
  cv2.namedWindow("3", cv2.WINDOW_NORMAL)
  cv2.namedWindow("4", cv2.WINDOW_NORMAL)
  cv2.namedWindow("5", cv2.WINDOW_NORMAL)
    
  doStep = singleStep = True
  done = False
  curFrame = start
  ret = movie.set(cv2.CAP_PROP_POS_FRAMES, curFrame)

  writer = None
  if path:
    base, ext = os.path.splitext(path)
    wrpath = base + "-crop.mp4"
    four_cc = cv2.VideoWriter_fourcc(*"MP4V")
    writer = cv2.VideoWriter(wrpath, four_cc, 18, (int(gate_width), int(gate_height)))
  
  while not done:
    if doStep or not singleStep:
      if doStep:
        print()
        
      doStep = False
      ret, frame = movie.read()
      if not ret or curFrame == gate_stats[-1, 0]:
        print("DONE")
        done = True
      else:
        sidx = curFrame - start
        idx1 = sidx - 5
        idx2 = sidx + 5
        if idx1 < 0:
          idx2 -= idx1
          idx1 = 0
        if idx2 > len(gate_stats):
          idx1 -= idx2 - len(gate_stats)
          idx2 = len(gate_stats)

        spr_tl = [0, gate_stats[sidx, GS_SPRTOP]]
        spr_br = gate_stats[sidx, GS_SPRRGT:GS_SPRHGT].copy()
        print("SPROCKET", spr_tl, spr_br)

        gate_tl = gate_stats[sidx, GS_GATELEF:GS_GATERGT].copy()
        gate_br = gate_stats[sidx, GS_GATERGT:GS_GATEBOT+1].copy()
        if gate_tl[0] is None and len(gate_stats[sidx]) >= 17:
          l1 = gate_stats[sidx, GS_GATEBOT]
          l2 = gate_stats[sidx, GS_GATEBOT+5]
          if l1 is not None and l2 is not None and abs(l1 - l2) < 10:
            gate_tl[0] = l1
          else:
            l1 = gate_stats[sidx, GS_GATEBOT+3]
            l2 = gate_stats[sidx, GS_GATEBOT+7]
            if l1 is not None and l2 is not None and abs(l1 - l2) < 10:
              gate_tl[0] = l1 - gate_width
        if gate_br[0] is None and len(gate_stats[sidx]) >= 17:
            l1 = gate_stats[sidx, GS_GATEBOT+3]
            l2 = gate_stats[sidx, GS_GATEBOT+7]
            if l1 is not None and l2 is not None and abs(l1 - l2) < 10:
              gate_br[0] = l1
            
        print("GATE", gate_tl, gate_br, gate_stats[sidx, GS_GATEBOT+1:])

        spr_top = get_mode(gate_stats[idx1:idx2, ], GS_SPRTOP)
        if spr_top is None:
          spr_top = crops[curFrame - start - 1][2] + gate_offset
        spr_rgt = get_mode(gate_stats[idx1:idx2, ], GS_SPRRGT)
        spr_bot = get_mode(gate_stats[idx1:idx2, ], GS_SPRBOT)

        print("MSPR", 0, spr_top, spr_rgt, spr_bot)

        gate_lef = get_mode(gate_stats[idx1:idx2, ], GS_GATELEF)
        gate_top = get_mode(gate_stats[idx1:idx2, ], GS_GATETOP)
        gate_rgt = get_mode(gate_stats[idx1:idx2, ], GS_GATERGT)
        gate_bot = get_mode(gate_stats[idx1:idx2, ], GS_GATEBOT)
        print("MGATE", gate_lef, gate_top, gate_rgt, gate_bot)
          
        if spr_tl[1] is None:
          spr_tl[1] = spr_top
        if spr_br[0] is None:
          spr_br[0] = spr_rgt
        if spr_br[1] is None:
          spr_br[1] = spr_bot
        if spr_br[1] is not None and spr_tl[1] is not None:
          spr_hgt = spr_br[1] - spr_tl[1]
        print("SPR HEIGHT", spr_hgt, sprocket_height)

        if spr_top is not None and spr_tl[1] is not None:
          spr_toff = abs(spr_top - spr_tl[1])
        if spr_rgt is not None and spr_br[0] is not None:
          spr_roff = abs(spr_rgt - spr_br[0])
        if spr_bot is not None and spr_br[1] is not None:
          spr_boff = abs(spr_bot - spr_br[1])
        if spr_hgt is not None:
          spr_hoff = abs(spr_hgt - sprocket_height)
        spr_ravg = np.array([spr_br[0], spr_rgt, gate_lef, gate_tl[0]])
        good = spr_ravg[np.where(spr_ravg is not None)]
        if len(np.where(good != None)[0]) > 0:
          spr_rmed = np.median(good)
        print("OFFSET", spr_toff, spr_roff, spr_boff, spr_hoff, spr_rmed)

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        h, w = gray.shape
        gblack = gray[int(h / 2), w - 1]
        mblack = np.where(gray <= gblack + 10)
        mwhite = np.where(gray > gblack + 10)
        gray[mblack] = 0
        gray[mwhite] = 255
        cols = np.sum(gray, axis=0)
        rows = np.sum(gray, axis=1)
        g_rows = 1 - (rows / (w * 255))
        g_cols = 1 - (cols / (h * 255))

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gwhite = gray[int(h/2), 0]
        mblack = np.where(gray < gwhite - 10)
        mwhite = np.where(gray >= gwhite - 10)
        gray[mblack] = 0
        gray[mwhite] = 255
        rows = np.sum(gray, axis=1)
        s_rows = rows / (w * 255)
        cols = np.sum(gray[:int(h/2)], axis=0)
        s_tcols = cols / ((h / 2) * 255)
        cols = np.sum(gray[int(h/2):], axis=0)
        s_bcols = cols / ((h / 2) * 255)
        
        tb_offset = frame.shape[0] - gate_height
        top_rows = g_rows[:tb_offset]
        bot_rows = g_rows[frame.shape[0] - tb_offset:]
        tmax = np.max(top_rows)
        tmax2 = tmax - 0.01
        w = np.where(top_rows < tmax - 0.01)
        if len(w[0]):
          tmax2 = np.max(top_rows[w])
        bmax = np.max(bot_rows)
        bmax2 = bmax - 0.01
        w = np.where(bot_rows < bmax - 0.01)
        if len(w[0]):
          bmax2 = np.max(bot_rows[w])
        tpeaks, _ = find_peaks(top_rows, tmax2 - 0.01)
        bpeaks, _ = find_peaks(bot_rows, bmax2 - 0.01)
        bpeaks += frame.shape[0] - tb_offset
        if not len(tpeaks):
          tpeaks = np.where(top_rows == tmax)[0]
        if not len(bpeaks):
          bpeaks = np.where(bot_rows == tmax)[0]
        used_bounds = used_border = False

        lcheck1 = np.zeros(shape=gray.shape, dtype=np.uint8)
        for y, v in enumerate(s_rows):
          x = int(v * lcheck1.shape[1])
          cv2.line(lcheck1, (0, y), (x, y), 255, 5)

        lcheck2 = np.zeros(shape=gray.shape, dtype=np.uint8)
        for x, v in enumerate(s_tcols):
          y = int(v * lcheck2.shape[0] / 2)
          cv2.line(lcheck2, (x, int(h/2)), (x, int(h/2)-y), 255, 5)
        for x, v in enumerate(s_bcols):
          y = int(v * lcheck2.shape[0] / 2)
          cv2.line(lcheck2, (x, int(h/2)), (x, int(h/2)+y), 255, 5)

        lcheck1 &= lcheck2
        h, w = lcheck1.shape
        y1 = int(h/2 - sprocket_height / 2 - (h - gate_height))
        y2 = y1 + sprocket_height + (h - gate_height) * 2
        x1 = 0
        x2 = w - gate_width + 10
        spr_mask = lcheck1[y1:y2, x1:x2]

        h, w = spr_mask.shape[:2]
        m = int((frame.shape[0] - gate_height) / 2)
        mask = np.zeros((h + 2, w + 2), np.uint8)
        cv2.floodFill(spr_mask, mask, (0, int(h/2)), 127, loDiff=2, upDiff=2);
        spr_mask = mask[1:-1, 1:-1] * 255
        sprocket_c = cv2.Canny(spr_mask, 50, 100, apertureSize=3)
        cv2.imshow("5", spr_mask)
        s_nz = np.where(sprocket_c > 0)
        tsc = sprocket_c[:int(h/2) - m]
        s_tnz = np.where(tsc > 0)
        bsc = sprocket_c[int(h/2) + m:]
        s_bnz = np.where(bsc > 0)
        spr_pts = cv2.findNonZero(spr_mask)
        spr_pts.shape = (-1, 2)
        # spr_bounds = [0, np.min(spr_pts[:, 1]),
        #               get_mode(s_nz[1], None), np.max(spr_pts[:, 1])]
        spr_bounds = [0, get_mode(s_tnz[0], None),
                      get_mode(s_nz[1], None), get_mode(s_bnz[0], None)]
        if spr_bounds[1] is None:
          spr_bounds[1] = np.min(spr_pts[:, 1])
        spr_bounds[1] += y1
        if spr_bounds[3] is None:
          spr_bounds[3] = np.max(spr_pts[:, 1]) - int(h/2) + m
        spr_bounds[3] += y1 + int(h/2) + m
        if spr_bounds[2] is None:
          spr_bounds[2] = frame.shape[1]
        print("SPR_BOUNDS", spr_bounds, sprocket_height, spr_bounds[3] - spr_bounds[1])

        rmax = np.max(g_cols) - 0.15
        rgt_cols = g_cols[gate_width - 20:]
        rpeak = np.where(rgt_cols >= rmax)[0]
        rpeak += gate_width - 20
        rdiff = np.diff(rpeak)
        
        h_test = abs(spr_bounds[3] - spr_bounds[1] - sprocket_height)
        w2_test = w_test = abs(spr_bounds[2] - spr_br[0])
        if len(rpeak):
          w2_test = abs(np.min(rpeak) - gate_width - spr_bounds[2])
        w3_test = abs(spr_rgt - spr_bounds[2])
        if h_test <= 20 and (w_test <= 15 or w2_test < 10 or w3_test <= 5):
          print("USE BOUNDS")
          spr_tl[1] = spr_bounds[1] + \
                      int((spr_bounds[3] - spr_bounds[1]) / 2 - sprocket_height / 2)
          spr_br[1] = spr_tl[1] + sprocket_height
          spr_br[0] = spr_bounds[2]
          used_bounds = True
        else:
          print("BAD BOUNDS", h_test, w_test, w2_test, w3_test)

        tavg = np.average(top_rows)
        bavg = np.average(bot_rows)
        tmod = get_mode(top_rows, None)
        bmod = get_mode(bot_rows, None)
        print("GMAX", abs(tmax - bmax),
              "top=%0.5f/%0.5f/%0.5f/%0.5f" % (tmax, tmax2, tavg, tmod),
              "bot=%0.5f/%0.5f/%0.5f/%0.5f" % (bmax, bmax2, bavg, bmod),
              tpeaks, bpeaks)
        if len(tpeaks) and len(bpeaks) and \
           len(tpeaks) <= 5 and len(bpeaks) <= 5 and \
           (abs(tmax - bmax) < 0.3 or \
            ((tmax - tavg) / tmax > 0.70 and (bmax - bavg) / bmax > 0.70)) \
           and (not used_bounds or (tmax - tmax2 > 0.03 and bmax - bmax2 > 0.03)) \
           and tmod < tmax - 0.05 and bmod < bmax - 0.05:
          tb_diff = np.tile(bpeaks, len(tpeaks)).reshape(-1, len(tpeaks))
          tb_diff = np.subtract(tb_diff, tpeaks)
          tb_diff -= gate_height
          tb_diff = np.abs(tb_diff)
          tb_diff = np.reshape(tb_diff, (len(bpeaks), len(tpeaks)))
          best = np.unravel_index(tb_diff.argmin(), tb_diff.shape)
          print("NICE", tb_diff.shape, tb_diff, best)
          gate_tl[1] = tpeaks[best[1]]
          gate_br[1] = bpeaks[best[0]]
          spr_tl[1] = gate_tl[1] + gate_offset + 1
          used_border = True

        if len(rpeak):
          print("GRIGHT", rmax, np.min(rpeak), np.average(rpeak))
          if np.min(rpeak) > gate_width and len(np.where(rdiff > 1)[0]) == 0:
            print("NICE")
            gate_br[0] = np.min(rpeak)
            spr_br[0] = gate_tl[0] = gate_br[0] - gate_width + 1
        
        lcheck = np.ones(shape=gray.shape, dtype=np.uint8)
        lcheck *= 255
        for y, v in enumerate(g_rows):
          x = int(v * lcheck.shape[1])
          cv2.line(lcheck, (0, y), (x, y), 0, 5)
        cv2.imshow("3", lcheck)

        lcheck = np.ones(shape=gray.shape, dtype=np.uint8)
        lcheck *= 255
        for x, v in enumerate(g_cols):
          y = int(v * lcheck.shape[0])
          cv2.line(lcheck, (x, 0), (x, y), 0, 5)
        cv2.imshow("4", lcheck)

        if not used_border and not used_bounds and \
           ((spr_toff > 5 and spr_hoff > 2) or spr_hoff > 10 or spr_tl[1] - gate_offset < 0):
          print("BAD SPROCKET")
          prev_top = next_top = -1
          if sidx - 1 >= idx1 and gate_stats[sidx - 1, GS_SPRTOP] is not None:
            prev_top = gate_stats[sidx - 1, GS_SPRTOP]
          if sidx + 1 < idx2 and gate_stats[sidx + 1, GS_SPRTOP] is not None:
            next_top = gate_stats[sidx + 1, GS_SPRTOP]
          if spr_bot is not None and spr_br[1] is not None:
            spr_bdiff = abs(spr_bot - spr_br[1])
          print("PN", prev_top, next_top, spr_bdiff)
          if abs(prev_top - next_top) > 2 or abs(spr_tl[1] - prev_top) > 3 \
             or abs(spr_tl[1] - next_top) > 3:
            if spr_br[1] is not None \
               and (spr_bdiff <= 5 or (spr_top - gate_offset < 0 and spr_bdiff < 100) \
                    or abs(prev_top - next_top) < 3) \
               and spr_br[1] - sprocket_height - gate_offset >= 0:
              print("USE BOTTOM")
              spr_tl[1] = spr_br[1] - sprocket_height
            else:
              if spr_top - gate_offset >= 0:
                print("USE MODE TOP")
                spr_tl[1] = spr_top
              elif spr_bot - sprocket_height - gate_offset >= 0:
                print("USE MODE BOTTOM")
                spr_tl[1] = spr_bot - sprocket_height
              else:
                print("USE MODE ALL")
                spr_tl[1] = get_mode(gate_stats, GS_SPRTOP)
            doStep = False
            singleStep = True

        # if abs(spr_rgt - spr_br[0]) > 5:
        #   sg = -1
        #   gw = 0
        #   fix = True
        #   if gate_tl[0] is not None and gate_br[0] is not None:
        #     sg = abs(spr_br[0] - gate_tl[0])
        #     gw = gate_br[0] - gate_tl[0]
        #     print("RIGHT MAYBE", sg, gw, None in gate_stats[sidx, GS_GATELEF:GS_GATEBOT+2])
        #     if sg <= 5 and abs(gw - gate_width) <= 20:
        #       prev_rgt = next_rgt = -1
        #       if sidx - 1 >= idx1 and gate_stats[sidx - 1, GS_SPRRGT] is not None:
        #         prev_rgt = gate_stats[sidx - 1, GS_SPRRGT]
        #       if sidx + 1 < idx2 and gate_stats[sidx + 1, GS_SPRRGT] is not None:
        #         next_rgt = gate_stats[sidx + 1, GS_SPRRGT]
        #       print("PN", prev_rgt, next_rgt)
        #       if abs(prev_rgt - next_rgt) > 2:
        #         fix = False
        #   if fix:
        #     print("BAD RIGHT", sg, gw, gate_width)
        #     if gate_tl[0] is not None and abs(gate_lef - gate_tl[0]) <= 5:
        #       print("USE GATE")
        #       spr_br[0] = gate_tl[0]
        #     else:
        #       print("USE MODE")
        #       spr_br[0] = spr_rgt
        #     doStep = False
        #     singleStep = True

        if None not in spr_tl and None not in spr_br:
          sprocket = Bounds(spr_tl, br=spr_br)
        print("SPR FINAL", sprocket)
          
        crop = Bounds((sprocket.x2, sprocket.y1 - gate_offset), size=(gate_width, gate_height))
        recrop = True
        curFrame += 1

    if recrop:
      print("CROP", crop)
      cropped = frame[int(crop.y1):int(crop.y2+1), int(crop.x1):int(crop.x2+1)].copy()
      label = "%i" % (curFrame - 1)
      if writer:
        writer.write(cropped)
      inframe = cropped.copy()
      cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                  cv2.FONT_HERSHEY_SIMPLEX, 5, (0,0,0), 10)
      cv2.putText(inframe, label, (10, inframe.shape[0] - 40),
                  cv2.FONT_HERSHEY_SIMPLEX, 5, (255,255,255), 7)
      cv2.imshow("1", inframe)

      d_frame = frame.copy()
      if None not in gate_tl and None not in gate_br:
        cv2.rectangle(d_frame, tuple(gate_tl.astype(int)),
                      tuple(gate_br.astype(int)), CLR_LBLUE, 4)
      cv2.rectangle(d_frame, *crop.cv, CLR_WHITE, 4)

      y1 = gate_stats[sidx, GS_SPRTOP]
      x2, y2 = gate_stats[sidx, GS_SPRRGT:GS_SPRHGT]
      if y1 is not None:
        cv2.line(d_frame, (0, y1), (d_frame.shape[1], y1), CLR_YELLOW, 5)
      if y2 is not None:
        cv2.line(d_frame, (0, y2), (d_frame.shape[1], y2), CLR_YELLOW, 5)
      if x2 is not None:
        cv2.line(d_frame, (x2, 0), (x2, d_frame.shape[0]), CLR_YELLOW, 5)
      cv2.imshow("2", d_frame)
      recrop = False

      c_stats = [curFrame] + crop.aslist
      if len(crops) + start > curFrame:
        crops[curFrame - start] = c_stats
      else:
        crops.append(c_stats)
        
    key = cv2.waitKey(1)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
      doStep = True
    elif key == 32:
      singleStep = not singleStep
    elif key == ord('b'):
      singleStep = True
      frame_num = movie.get(cv2.CAP_PROP_POS_FRAMES)
      if frame_num > 1:
        curFrame -= 2
        ret = movie.set(cv2.CAP_PROP_POS_FRAMES, frame_num - 2)
        doStep = True
    elif key == ord('m'):
      crop.y1 -= 1
      if crop.y1 < 0:
        crop.y1 = 0
      recrop = True
    elif key == ord('i'):
      crop.y1 += 1
      if crop.y1 >= frame.shape[0]:
        crop.y1 = frame.shape[0] - 1
      recrop = True
    elif key == ord('k'):
      crop.x1 -= 1
      if crop.x1 < 0:
        crop.x1 = 0
      recrop = True
    elif key == ord('j'):
      crop.x1 += 1
      if crop.x1 >= frame.shape[1]:
        crop.x1 = frame.shape[1] - 1
      recrop = True

  if writer:
    writer.release()
  cv2.destroyAllWindows()
  return crops
  
def main():
  args = build_argparser().parse_args()

  movie = cv2.VideoCapture(args.file)
  ret = movie.set(cv2.CAP_PROP_POS_FRAMES, args.start)

  base, ext = os.path.splitext(args.file)
  wrpath = base + ".stats"
  if not args.stats:
    gate_stats = pass1(movie, args.start, args.end)
    print("TYPE", gate_stats.dtype)
    wr_stats = gate_stats.copy()
    wr_stats[np.where(wr_stats == None)] = -1
    np.savetxt(wrpath, wr_stats, fmt="%i")
  else:
    gate_stats = np.loadtxt(wrpath, dtype=np.int32)
    gate_stats = gate_stats.astype(object)
    gate_stats[np.where(gate_stats == -1)] = None

  if len(gate_stats):
    crops = pass2(movie, gate_stats, args.start, args.end, None)
    if len(crops):
      wrpath = base + ".crops"
      crops = np.array(crops)
      np.savetxt(wrpath, crops, fmt="%i")

  return

if __name__ == '__main__':
  exit(main() or 0)
