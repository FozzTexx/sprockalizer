#!/usr/bin/env python3
#
# I am the gate finder, are you the sprocket master?

import argparse
import os
import cv2
import numpy as np
import json
from sprocket import Sprocket
from scipy import stats
from gate import Gate
from line import Point, Bounds
from color import *

def build_argparser():
  parser = argparse.ArgumentParser()
  parser.add_argument("file", help="input file")
  parser.add_argument("stats", nargs="?", help="stats file to read")
  parser.add_argument("--start", default=0, type=int, help="frame number to start at")
  parser.add_argument("--end", default=-1, type=int, help="frame number to stop at")
  parser.add_argument("--nowait", action="store_true", help="don't wait for keypress to start")
  return parser

def pass1(path, start, nowait):
  base, ext = os.path.splitext(path)
  name = os.path.basename(base)

  movie = cv2.VideoCapture(path)
  ret = movie.set(cv2.CAP_PROP_POS_FRAMES, start)

  cv2.namedWindow(name, cv2.WINDOW_NORMAL)
  cv2.namedWindow("cropped", cv2.WINDOW_NORMAL)

  singleStep = not nowait

  stats = []
  frame_num = 0
  spr_height_avg = 0
  spr_height_count = 0
  spr_height_done = False
  while True:
    ret, frame = movie.read()
    if not ret:
      done = True
      break
    # frame_num += 1
    # print(frame_num, "\r", end="")

    # FIXME - auto white point
    # FIXME - auto black point

    sprocket = Sprocket(frame)

    if spr_height_done:
      if not sprocket.top:
        if not sprocket.bottom:
          # print("SPROCKET RIGHT", sprocket.right)
          continue
        sprocket.top = sprocket.bottom - spr_height_avg
      sprocket.bottom = sprocket.top + spr_height_avg

    gate = Gate(frame, sprocket)
    stats.append([sprocket, gate])

    # if gate.bounds:
    #   print("GATE", gate.bounds)

    if False and sprocket.top and sprocket.bottom:
      corr_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
      planes = cv2.split(corr_frame)
      lum_plane = planes[2].astype(np.float32)
      spr_center = int((sprocket.bottom - sprocket.top) / 2 + sprocket.top)
      white = lum_plane[spr_center, 0]
      black = lum_plane[0, lum_plane.shape[1] - 1] / 2
      # print("WHITE", white)
      # print("BLACK", black)
      scale = 255 / (white - black)
      lum_scaled = np.clip((lum_plane[:, :] - black) * scale, 0, 255)
      corr_frame[:, :, 2] = lum_scaled
      frame = cv2.cvtColor(corr_frame, cv2.COLOR_HSV2BGR)

    if gate.bounds:
      cv2.line(frame, (0, int(gate.bounds.y1 - gate.MARGIN)),
               (frame.shape[1], int(gate.bounds.y1 - gate.MARGIN)),
               CLR_RED, 5)
      cv2.line(frame, (0, int(gate.bounds.y1 + gate.MARGIN)),
               (frame.shape[1], int(gate.bounds.y1 + gate.MARGIN)),
               CLR_RED, 5)
      cv2.line(frame, (0, int(gate.bounds.y2 - gate.MARGIN)),
               (frame.shape[1], int(gate.bounds.y2 - gate.MARGIN)),
               CLR_RED, 5)
      cv2.line(frame, (0, int(gate.bounds.y2 + gate.MARGIN)),
               (frame.shape[1], int(gate.bounds.y2 + gate.MARGIN)),
               CLR_RED, 5)

      pt1 = Point(gate.bounds.x1 + gate.MARGIN, gate.bounds.y1 + gate.MARGIN)
      pt2 = Point(gate.bounds.x2 - gate.MARGIN, gate.bounds.y2 - gate.MARGIN)
      crop_bounds = Bounds(pt1, br=pt2)
      if crop_bounds.x1 >= 0 and crop_bounds.y1 >= 0 \
         and crop_bounds.width > 0 and crop_bounds.height > 0:
        crop = frame[crop_bounds.y1:crop_bounds.y2, crop_bounds.x1:crop_bounds.x2, :]
        cv2.imshow("cropped", crop)
      else:
        print("BAD CROP", crop_bounds)

    cv2.imshow(name, frame)

    delay = 0
    if not singleStep:
      delay = 1
    key = cv2.waitKey(delay)
    if key == 27:
      done = True
      break
    elif key == 13:
      singleStep = True
    elif key == 32:
      singleStep = not singleStep

  cv2.destroyAllWindows()
  return stats

def get_mode(arr, col):
  if col is not None:
    a = arr[:, col]
  else:
    a = arr
  a = a[a[:] != None]
  if len(a) == 0:
    return None
  return stats.mode(a)[0][0]

def pass2(path, start, stats, nowait=False):
  sprockets = []
  gates = []
  for sprocket, gate in stats:
    if sprocket.bounds:
      sprockets.append(sprocket.bounds.aslist
                       + [sprocket.bounds.width, int(sprocket.bounds.height)])
    if gate.bounds:
      gates.append((gate.bounds.width, gate.bounds.height))
  sprockets = np.array(sprockets)
  gates = np.array(gates)

  gate_size = [int(get_mode(gates, 0)), int(get_mode(gates, 1))]
  sprocket_height = get_mode(sprockets, 5)
  #sprocket_height = np.mean(sprockets[:, 5])
  print("GATE SIZE", gate_size)
  print("SPROCKET HEIGHT", sprocket_height)

  gate_distances = []
  for sprocket, gate in stats:
    if sprocket.top and sprocket.right:
      sprocket_corner = Point(sprocket.right, sprocket.top)
    elif sprocket.bottom and sprocket.right:
      sprocket_corner = Point(sprocket.right, sprocket.bottom - sprocket_height)
    else:
      continue

    if gate.bounds:
      gate_distances.append([sprocket_corner.y - gate.bounds.y1])
  gate_distances = np.array(gate_distances)
  gate_dist = get_mode(gate_distances, 0)
  print("GATE DIST", gate_dist)

  base, ext = os.path.splitext(path)
  name = os.path.basename(base)

  movie = cv2.VideoCapture(path)
  ret = movie.set(cv2.CAP_PROP_POS_FRAMES, start)
  cv2.namedWindow(name, cv2.WINDOW_NORMAL)
  cv2.namedWindow("cropped", cv2.WINDOW_NORMAL)
  cv2.namedWindow("overlap", cv2.WINDOW_NORMAL)

  singleStep = not nowait
  crops = []
  for sprocket, gate in stats:
    if sprocket.top and sprocket.right:
      sprocket_corner = Point(sprocket.right, sprocket.top)
    elif sprocket.bottom and sprocket.right:
      sprocket_corner = Point(sprocket.right, sprocket.bottom - sprocket_height)
    else:
      sprocket_corner = Point(get_mode(sprockets, 2), get_mode(sprockets, 1))

    if gate.bounds:
      gate_corner = gate.bounds.origin
    else:
      gate_corner = Point(sprocket_corner.x, sprocket_corner.y - gate_dist)

    cur_dist = sprocket_corner.y - gate_corner.y
    # print("GATE DIST", gate_dist - cur_dist)
    if abs(gate_dist - cur_dist) > 5:
      gate_corner = Point(gate_corner.x, sprocket_corner.y - gate_dist)
    if gate_corner.y < 0:
      gate_corner = prev_corner

    ret, frame = movie.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    u_offset = gate_corner.cv[1] + 40
    l_offset = gate_corner.cv[1] + gate_size[1] - 100
    upper = gray[:u_offset, gate_corner.cv[0] + 10:]
    upper = cv2.resize(upper, None, fx=3, fy=3)
    overlap = cv2.Canny(upper, 50, 100, apertureSize=3)
    cv2.imshow("overlap", overlap)

    prev_corner = gate_corner
    crop_bounds = Bounds(gate_corner.cv, size=gate_size)
    print("CROP BOUNDS", crop_bounds)
    crop = frame[crop_bounds.y1:crop_bounds.y2, crop_bounds.x1:crop_bounds.x2, :]
    cv2.imshow("cropped", crop)

    cv2.line(frame, (0, int(sprocket_corner.y)), (frame.shape[1], int(sprocket_corner.y)),
             CLR_YELLOW, 5)
    cv2.line(frame, (0, int(sprocket_corner.y + sprocket_height)),
             (frame.shape[1], int(sprocket_corner.y + sprocket_height)), CLR_YELLOW, 5)
    cv2.line(frame, (sprocket_corner.x, 0), (sprocket_corner.x, frame.shape[0]),
             CLR_YELLOW, 5)
    
    cv2.line(frame, (0, crop_bounds.y1), (frame.shape[1], crop_bounds.y1), CLR_GREEN, 5)
    cv2.line(frame, (0, crop_bounds.y2), (frame.shape[1], crop_bounds.y2), CLR_GREEN, 5)
    cv2.line(frame, (crop_bounds.x1, 0), (crop_bounds.x1, frame.shape[0]), CLR_GREEN, 5)
    cv2.line(frame, (crop_bounds.x2, 0), (crop_bounds.x2, frame.shape[0]), CLR_GREEN, 5)
    
    cv2.imshow(name, frame)

    delay = 0
    if not singleStep:
      delay = 1
    key = cv2.waitKey(delay)
    if key == 27:
      break
    elif key == 13:
      singleStep = True
    elif key == 32:
      singleStep = not singleStep

    crops.append(crop_bounds)

  return crops

def main():
  args = build_argparser().parse_args()

  base, ext = os.path.splitext(args.file)
  name = os.path.basename(base)

  stats_path = base + ".stats"
  if not args.stats:
    stats = pass1(args.file, args.start, args.nowait)
    with open(stats_path, "w") as f:
      for sprocket, gate in stats:
        spr_bounds = [sprocket.top, sprocket.bottom, sprocket.right]
        if gate.bounds:
          gate_bounds = gate.bounds.aslist
        else:
          gate_bounds = [None, None, None, None]
        f.write(json.dumps(spr_bounds + gate_bounds) + "\n")
  else:
    with open(stats_path, "r") as f:
      stats = []
      while True:
        jdata = f.readline()
        if not jdata:
          break
        jdata = json.loads(jdata)
        spr = Sprocket(None)
        spr.top = jdata[0]
        spr.bottom = jdata[1]
        spr.right = jdata[2]
        gate = Gate(None, spr)
        if jdata[3] is not None:
          gate.bounds = Bounds(jdata[3:5], br=jdata[5:7])
        stats.append([spr, gate])

  crops = pass2(args.file, args.start, stats)
  wrpath = base + ".crops"
  with open(wrpath, "w") as f:
    for idx, row in enumerate(crops):
      f.write(json.dumps([args.start + idx, ] + np.array(row.aslist).tolist()) + "\n")

  return

if __name__ == '__main__':
  exit(main() or 0)
